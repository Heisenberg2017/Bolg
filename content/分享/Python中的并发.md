---
title: "Python中的并发"
date: 2019-11-29T13:56:35+08:00
draft: false
---

介绍下世界最火编程语言的并发模型
<!--more-->

## 斐波那契数列
```
+------------------------------------------+
|             Fibonacci数列                 |
|------------------------------------------|
| 斐波那契数列指的是这样一个数列              |
| 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...    |
|                                          |
| 这个数列从第3项开始，每一项都等于前两项之和  |
|  2 = 1 + 1                               |
|  3 = 2 + 1                               |
|  5 = 3 + 2                               |
|  8 = 5 + 3                               |
| 13 = 8 + 5                               |
| ...                                      |
+------------------------------------------+
```
什么是I/O密集和CPU密集?

```python
# fib.py
def fib(n):
    if n <= 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)
```


<!--
开始演示斐波那契数列的特点
    0.为什么一开始要讲斐波那契数列,因为它非常适合模拟cpu密集的情况
    1.我这里实现了一个计算fib的函数时间复杂度是O(2^n)
    2.稍微解释下这个概念
    3.例如：计算1要1微秒，10就需要1毫秒，20需要1秒，30要1000秒，100要14671881947085988443天
    4.验证下这个概念
    1.ipython -i fib.py
    2.验证数字1 10 20 30 35 38
    6.看一下是不是要黑一下PHP
    （讲一个事情，真事，不是黑，不要因为一般学习各门语言编程书一般都会有个计算fib数的例子吧，c python go rust java，
     我有一天发了个计算各语言fib性能对比的博客给我朋友看，我朋友说fib是啥，我很诧异，我说你写代码，或者看代码书的
     时候都没有接触过吗？他说我们写PHP的不需要这个）
-->

<!--
开始对外提供服务的概念
    0.fib适合模拟cpu密集的情况
    1.现在我还需要模拟一个i/o密集的情况用作对照
    3.i/o包括读写磁盘，网络传输
    4.我这里用网络传输来模拟io
    5.所以 我现在准备对外提供这个计算fib的微服务
-->
  

## 单线程

什么是单线程?

是操作系统能夠進行運算调度的最小單位。
 大部分情况下，它被包含在进程之中，是进程中的實際運作單位。
 一条线程指的是进程中一个单一顺序的控制流，一個进程中可以並行多個线程，每条线程并行执行不同的任务。
<br>

单线程有没有什么问题或者缺陷？

对外提供web服务，使用单线程的程序只能对一个在线用户进行服务

<br><br>

如何验证上面的观点?

1.实现一个对提供计算斐波那契额数的服务

这里我们已经实现好了直接python one_server.py运行就可以对外提供服务

2.使用 nc 连接上去，看下对外提供服务的情况

3.顺便测试下性能 python perf2.py

<br><br><br>


<!--
开始演示单线程
    0.fib适合模拟cpu密集的情况
    1.现在我还需要模拟一个i/o密集的情况用作对照
    3.i/o包括读写磁盘，网络传输
    4.我这里用网络传输来模拟io
    5.所以 我现在准备对外提供这个计算fib的微服务
    6.开始操作
    7.一个客户端IO密集
    8.开始提问，你们知道单线程情况下第二个客户端上来会怎么样吗?
    9.第二个客户端链接，没有任何回应
    10.上面使用nc
    10.上图
    11.讲讲为什么没有回应
    12.最后做下性能测试
-->

运行时草图
```
+----------------------------+
|  Process                   |                  +-----------+
|              main thread   |        send      |           |
|             +----------+   |  <-------------+ |           |
|             |   recv   |   |                  |  client1  |
|             |    |     |   |  +-------------> |           |
|             |   fib(n) |   |        resp      |           |
|             |    |     |   |                  +-----------+
|             |   send   |   |
|             +----------+   |
|                            |      connect     +-----------+
|             +----------+   |  <-------------+ |           |
|             |  accept  |   |                  |  client2  |
|             +----------+   |      无 响 应     |           |
+----------------------------+                  +-----------+
```

这个例子中的单线程遵守下面的原则

原则:

 * 谁先来为谁服务

 * 上一个走了才能为下一个人服务
 
<!--
我们如何让它服务多个客户端，任何服务都是需要服务多客户端的
    1.类比生活中的例子
    0.单线程同一个时间只能对一个人服务,所以我们需要多线程
    2.开始一顿操作
    3.先使用nc 让大家看到可以两个同时连接上去
    4.多线程
    5.开始性能测试
    6.第二个客户端链接上之前提问大家，性能会有什么变化
    6.对比I/O密集 CPU密集情况下处理第二个客户端的性能变化
    7.引出GIL
-->

## 多线程

为什么要有多线程?

因为单线程无法处理多个用户同时访问web服务的情况

多线程有没有什么问题或者缺陷？

有GIL导致无法使用多核核心

如何验证上面的观点?

1.实现一个对提供计算斐波那契额数的多线程服务

这里我们已经实现好了直接python thread_server.py运行就可以对外提供服务

2.使用 nc 连接上去，看下对外提供服务的情况,这里关注两个nc连接上去是否都会有应答

3.顺便测试下性能 python perf2.py

<br><br><br>

运行时草图
```python
+----------------------------------------+
|  Process                   thread1     |                  +-----------+
|                          +----------+  |        send      |           |
|                          |   recv   |  |  <-------------+ |           |
|                          |    +     |  |                  |  client1  |
|                   +--------->fib(n) |  |  +-------------> |           |
|                   |      |    +     |  |        resp      |           |
|    +-------+      |      |   send   |  |                  +-----------+
|    |       |      |      +----------+  |
|    |  GIL  +------+                    |
|    |       |      |         thread2    |                  +-----------+
|    +-------+      |      +----------+  |        send      |           |
|                   |      |   recv   |  |  <-------------+ |           |
|                   |      |    +     |  |                  |  client1  |
|                   ---------->fib(n) |  |  +-------------> |           |
|                          |    +     |  |        resp      |           |
|                          |   send   |  |                  +-----------+
|                          +----------+  |
|                                        |
|                                        |
|                           main thread  |      connect     +-----------+
|                          +----------+  |  <-------------+ |           |
|                          |  accept  |  |                  |  client2  |
|                          +----------+  |  +-------------> |           |
+----------------------------------------+        resp      +-----------+
```



## GIL
![Python多线程](/images/Python多线程.gif "Python多线程")

为什么会有GIL?

因为Python的内存管理不是线程安全的
啥是线程安全，这个后面讲，在引出Python的内存管理之后
python多线程是鸡肋，由于GIL的存在只能利用一个CPU? 
实际上GIL是Cpython的

Python如何进行内存管理?

引用计数为主，标记-清除和分代收集两种机制


## 内存管理
问题: 学校有一些办公场所用于租给各个部门协会，办公场所是有限的，你会如何管理这些场地的分配和回收？

以下是条件

 * 每个协会/部门及任何人都可以租用场地
 * 允许共用一块场地
 * 当一个场地没有任何人使用时需要进行回收，然后等待其他部门申请用于其他的用途

几个方案

0.直接申请，不要的时候再告诉学校，如果你忘记了，这块空间就一直处于不可以用的情况

1.定时询问，比如每周五询问一次有没有人使用，全部统计结束前的时候不允许分配场地，避免出现刚才统计结果不一致
这种方法需要停止所有场地的分配，还要询问等待所有人回复

2.引用计数，竞争，因为分配和增加引用时很频繁的，频繁的锁解锁十分的影响性能

3.拥有权，部门协会申请后在某个区间范围内可以使用这片区域，例如有个活动开始申请，活动结束立马就回收

。。。。。。


## 多进程

为什么要有多进程?

存在GIL使得Python多线程无法利用多个核心

多进程有没有什么问题或者缺陷？

fork系统调用太慢，multiprocess由于引用计数还导致了Python用不了linux写时复制的功能,
耗费内存太多

如何验证上面的观点?
1.实现一个对提供计算斐波那契额数的有多进程服务

这里我们已经实现好了直接python multiprocess_server.py运行就可以对外提供服务


2.测试性能 python perf2.py


运行时草图

```
+---------------------+       +----------------------------------------+
    Process Pool      |       | Process                                |
                      |       |                                        |
      +-----------+   |       |                            thread1     |
      |Process1   |   |       |                          +----------+  |
      |   +-----+ |   |       |                          |   recv   |  |
      |   | GIL | |   |       |                          |    +     |  |
      |   +-----+ |   |  <--------------------------------+ submit  |  |
      +-----------+   |       |                          |    +     |  |
                      |  +--------------------------------> result  |  |
      +-----------+   |       |                          |    +     |  |
      |Process2   |   |       |                          |   send   |  |
      |   +-----+ |   |       |                          +----------+  |
      |   | GIL | |   |       |                                        |
      |   +-----+ |   |       |                            thread2     |
      +-----------+   |       |                          +----------+  |
                      |       |                          |   recv   |  |
      +-----------+   |       |                          |    +     |  |
      |Process3   |   |  <--------------------------------+ submit  |  |
      |   +-----+ |   |       |                          |    +     |  |
      |   | GIL | |   |  +--------------------------------> result  |  |
      |   +-----+ |   |       |                          |    +     |  |
      +-----------+   |       |                          |   send   |  |
                      |       |   +-------+              +----------+  |
            X         |       |   |       |                            |
                      |       |   |  GIL  |     其 余 部 分 同多 线 程 版 本     |
            X         |       |   |       |                            |
                      |       |   +-------+                            |
            X         |       |                                        |
 +--------------------+       +----------------------------------------+


```







## 协程

为什么要有协程?
为什么一个线程只能为一个客户服务，对比现实世界，
一个人只能为一个客户服务，这样太浪费了，为什么不能一个人，同时为多人服务？

协程有没有什么问题或者缺陷？

协程在I/O密集情况下可以发挥最大的作用，如果时CPU密集会导致协程阻塞,这个时候仍需要使用multiprocess

如何验证上面的观点?

1.使用这里我们已经实现好了直接aserver.py运行就可以对外提供服务

2.只测试不使用multiprocess情况，使用multiprocess的情况可以自己修改下代码去复现


运行时草图
```python
 Thread
   |
   |       +---------------+
   |       |               |
   |       |  代 码 块 A    |
   |       |               |
   |       |               |
   |       +---------------+
   |                                 +----------------+
时 |                                 |                |
   |                                 |   代 码 块 B    |
间 |                                 |                |
   |                                 +----------------+
   |
   |       +---------------+
   |       |  代 码 块 A    |
   |       +---------------+
   |                                 +----------------+
   |                                 |   代 码 块 B    |
   |                                 +----------------+
   |
   |
   v

```



## 大多数Web框架的方案

大多数的Python Web服务会采用下面的方式进行并发，而不是multiprocess

app1: python many_server.py 25000

app2: python many_server.py 25001


## 未来绕过GIL的方案

讲讲子解释器的事情


## 性能测试

I/O 密集情况下:

代码    | 1个客户端    | 2个客户端
:---- | :---- | :----
one_server | 12 000 reqs/sec | 无法对外提供服务
thread_server |  12 000 reqs/sec  |  16 000 reqs/sec
multiprocess_server |  3 500  reqs/sec  |  4 300 reqs/sec
many_server |  12 000  reqs/sec  |  20000 reqs/sec
go_server |  12 000 reqs/sec  |  20 000 reqs/sec
async_server | 8 000 reqs/sec  |  14 000 reqs/sec
subinterpreters_server &nbsp;&nbsp;&nbsp;&nbsp; | 4 000 reqs/sec &nbsp;&nbsp;&nbsp;&nbsp; |  5 000 reqs/sec

CPU 密集情况下:

代码    | 1个客户端    | 2个客户端
:---- | :---- | :----
one_server | 400    reqs/sec         |      无法对外提供服务
thread_serve | 400    reqs/sec         |        400 reqs/sec
multiprocess_server | 400    reqs/sec     |             700 reqs/sec
many_server  |  400 reqs/sec            |        800 reqs/sec
go_server   |  7 500    reqs/sec     |       11 000 reqs/sec
async_server     | 不再延伸             |     不再延伸
subinterpreters_server &nbsp;&nbsp;&nbsp;&nbsp; | 350reqs/sec &nbsp;&nbsp;&nbsp;&nbsp; |  350reqs/sec






## python vs golang


国内很多大厂迁移到go或者重度使用go,性能，不能利用多核，太废内存
为此google甚至启动了一个疯狂的项目


## 扩展阅读:
[CPU密集和I/O密集](https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean)
在stackoverflow上的解释

这次分享部分代码都来自David Beazley在PyCon2015的一场演讲
[Python Concurrency From the Ground Up: LIVE! - PyCon 2015](https://www.youtube.com/watch?v=MCs5OvhV9S4)
新版本Python代码的行为和演讲中已经不完全一样了，但仍然值得一看

讲讲啥是[GIL](http://cenalulu.github.io/python/gil-in-python/)

[GIL已死?](https://medium.com/hackernoon/has-the-python-gil-been-slain-9440d28fa93d)
答案是没死，讲了Python在新版本中可能用于绕过GIL的方案

如何阅读CPYTHON [cpython-source-code-guide](https://realpython.com/cpython-source-code-guide/)

youtube前端大量使用Python，在各种优化方案都渐渐失去效果时，鬼魅想法涌上心头
[google疯狂的项目](https://github.com/google/grumpy)

InfoQ 说说 [grumpy](https://www.infoq.cn/article/2017/01/Grumpy-Google-Go-Python) 也就是上面说的疯狂的项目

Python写时复制,引用计数导致多进程程无法利用写时复制,Python优化文章大厂Instagram出品
[译文](https://learnku.com/python/t/22973/instagram-actual-combat-exploring-write-time-replication-friendly-python-garbage-collection-mechanism)
[原文](https://instagram-engineering.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172)